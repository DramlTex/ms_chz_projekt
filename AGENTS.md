Agents.md — Документация проекта ms_products-main
Цель проекта

ms_products-main – это веб-приложение на Flask, предназначенное для интеграции учетной системы МойСклад с национальными системами маркировки и каталогизации товаров. Проект автоматизирует процессы заказа и учета кодов маркировки товаров, поддерживает агрегирование кодов, а также обеспечивает обмен данными с внешними сервисами:

ГИС МТ (государственная информационная система «Честный Знак» – True API),

СУЗ (облачная Система управления заказами кодов маркировки),

НК (Национальный каталог товарной продукции),

и другими связанными системами.

Приложение позволяет получать информацию о товарах из МойСклад и отправлять товарные карточки в Национальный каталог

. Кроме того, оно интегрировано с инфраструктурой маркировки «Честный Знак» для заказа кодов маркировки (КМ) через СУЗ и последующего ввода товаров в оборот, отслеживания статусов кодов и оформления отгрузок и приемок. В итоге, цель проекта – упростить для пользователя выполнение требований по маркировке: от заказа и печати КМ до передачи сведений о вводе товара в оборот, движении и выводе из оборота в централизованные гос. системы.
ТАк же есть AGENTSCS.md, AGENTS_DOCUMENTATION_STANDARD.md, WEB_PAGES_DOCUMENTATION_STANDARD.md ТАм лежат примеры запросов и стандарты для разработки если это надо иди в эти файли и смотри эти файлы. Если нет то читай дальше.

Общие правила разработки

При разработке и добавлении нового функционала необходимо придерживаться принципов модульности и изоляции изменений. Любое новое изменение должно быть реализовано таким образом, чтобы не затрагивать существующие режимы работы приложения, если оно явно не активировано. В частности:

Изоляция функционала: новый код не должен ломать или изменять логику в других частях системы по умолчанию. Добавляемые модули или функции должны быть максимально независимы и подключаться только при необходимости.

Фиче-флаги и настройки: если новый функционал рассчитан на специфичный режим работы или особый кейс, его выполнение должно происходить только при включении соответствующей настройки (например, через параметр конфигурации, переменную окружения или опцию в интерфейсе). В выключенном состоянии такие фичи не влияют на систему.

Обратная совместимость: старайтесь поддерживать прежние режимы работы. Если требуется изменить существующую логику, убедитесь, что это не нарушит работу у текущих пользователей, или оградите изменения за условием.

Чистая архитектура: размещайте код нового функционала отдельно (например, в новом модуле или файле), избегайте монолитных изменений. Это облегчает поддержку и тестирование, а также позволяет при необходимости откатить или отключить нововведение без побочных эффектов.

Следуя этим правилам, проект остаётся устойчивым к изменениям: каждая новая возможность добавляется как самостоятельный компонент, не нарушая работу других частей приложения.

Работа с проектом
Установка и настройка окружения

Клонирование репозитория. Начните с получения кода проекта:

git clone <репозиторий> ms_products-main
cd ms_products-main


(Или скопируйте файлы проекта другим удобным способом.)

Создание виртуального окружения и установка зависимостей. Проект написан на Python, поэтому рекомендуется создать виртуальное окружение. Затем установите необходимые библиотеки командой pip install -r requirements.txt
GitHub
. Пример:

python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt


Настройка переменных окружения. Переименуйте файл настроек:

cp .env.example .env


Откройте файл .env и укажите в нём все требуемые ключи и токены. Минимально необходимо задать:

MS_TOKEN – токен доступа к API МойСклад (для получения данных товаров),

NC_API_KEY – API-ключ для доступа к Национальному каталогу,

OMS_ID – идентификатор устройства/соединения в системе СУЗ (при наличии, используется для заказа кодов),

а также базы URL для API: TRUE_API_BASE, SUZ_API_BASE и др. По умолчанию .env пример уже содержит боевые адреса:

TRUE_API_BASE=https://markirovka.crpt.ru/api/v3/true-api 
SUZ_API_BASE=https://suz.crpt.ru/api/v3 
NC_BASE_URL=https://xn--80aqu.xn----7sbabas4ajkhfocclk9d3cvfsa.xn--p1ai 



Убедитесь также, что в .env прописаны учётные данные МойСклад (если используются Basic Auth) и другие настройки, необходимые вашему сценарию.

Конфигурация проекта. Откройте файл config.py и проверьте настройки соответствия полей (например, названия кастомных атрибутов МойСклад для признаков маркировки, состава, цвета и проч. должны совпадать с теми, что используются в вашем аккаунте)
GitHub
. При необходимости скорректируйте словари и константы, чтобы они соответствовали реальным данным. Например, убедитесь, что название флажка для пометки товаров "Для нац.каталога" совпадает
GitHub
.

Сборка фронтенд-ресурсов. В проекте используется Tailwind CSS для стилизации интерфейса, а сборка CSS организована через инструмент Vite. Перед первым запуском вам необходимо установить фронтенд-зависимости и собрать стили:

npm install
npm run build


Эти команды сгенерируют файл static/dist/tailwind.css, подключаемый приложением
GitHub
. (Примечание: убедитесь, что Node.js установлен.)

Запуск приложения. После успешной установки зависимостей и конфигурации запустите Flask-приложение:

python app.py


По умолчанию сервер стартует на адресе 0.0.0.0:5000
GitHub
. Вы можете изменить хост и порт при необходимости через переменные окружения FLASK_HOST и FLASK_PORT
GitHub
. Для включения режима отладки установите FLASK_DEBUG=true в .env. Если требуется запускать приложение по HTTPS, укажите пути к SSL-сертификату и ключу в переменных SSL_CERT и SSL_KEY
GitHub
.

Доступ к функционалу. После запуска убедитесь, что приложение доступно в браузере. Войдите в систему (используется авторизация через учетные данные MoySklad или токены). На главной странице вы увидите таблицу товаров, загруженных из МойСклад. Интерфейс предоставляет возможности фильтрации по флажку "Для нац.каталога", предварительного просмотра карточек товара для НК, отправки данных в НК, проверки статусов, а также разделы для управления кодами маркировки.

JSON-структуры и тестовые скрипты

Для корректной работы с интеграциями важно понимать формат данных, возвращаемых внешними API (МойСклад, НК, ГИС МТ). В репозитории предусмотрены материалы и утилиты для ознакомления с этими структурами:

В каталоге docs/ (например, файл docs/structure.md) и в папке example/ приведены примеры JSON-структур ответов от API. Эти примеры демонстрируют, как выглядят объекты товаров, карточек НК, коды маркировки и пр. Используйте их как ориентир при разработке, чтобы обращаться к нужным полям.

При обновлении API или интеграции новых сущностей вы можете сгенерировать актуальные структуры с помощью тестовых скриптов. В папке test/ (или scripts/) находятся утилиты для отладки. Например, скрипты могут выполнять запросы к API МойСклад или НК и выводить полученный JSON. Запустив такие скрипты, вы получите свежий пример структуры данных, с которым проще разрабатывать парсинг и логику.

Пример: Скрипт scripts/generate_gtin.py демонстрирует обращение к API НК для генерации GTIN и заодно показывает, как из МойСклад можно получить ИНН организации
GitHub
. Аналогично, вы можете написать или использовать имеющиеся скрипты для запроса списка товаров из МойСклад или шаблонного заказа КМ через True API, чтобы увидеть формат ответов.

Перед началом разработки новой функциональности убедитесь, что вы обладаете актуальной схемой данных. Воспользуйтесь официальной документацией (например, документация API МойСклад доступна на сайте разработчиков
GitHub
) и приведёнными в проекте примерами. Это поможет избежать ошибок из-за неверных предположений о структуре JSON.

Правила интерфейса

В проекте реализован веб-интерфейс, использующий Tailwind CSS для оформления и придерживающийся единообразного дизайна. При добавлении новых страниц или элементов интерфейса важно соблюдать существующий стиль и UX-паттерны:

Tailwind CSS и дизайн: Используйте утилитарные CSS-классы Tailwind для разметки и оформления вместо написания новых CSS-правил, если это возможно. В проекте подключён сгенерированный файл Tailwind (tailwind.css), за которым могут следовать дополнительные стили приложения
GitHub
. Новые компоненты следует оформлять комбинацией существующих Tailwind-классов, чтобы сразу применять актуальную цветовую схему и адаптивность. Например, для отступов, выравнивания, цветовых заливок используйте стандартные утилиты Tailwind вместо инлайновых стилей.

Компонентная библиотека: Проект использует готовые стилевые компоненты на базе Tailwind. Например, подключён DaisyUI (на это указывают классы вроде btn, modal, select и атрибут data-theme в <html>
GitHub
GitHub
). Это значит, что кнопки, выпадающие списки, вкладки и другие элементы уже имеют оформленный вид. Придерживайтесь этих компонентов: для новых кнопок используйте классы btn/btn-primary/btn-outline и прочие вариации, для вкладок — классы tab и т.д., как сделано в существующем коде. Например, кнопки "Отмена" и "Войти" в модальном окне подключаются с классами btn btn-ghost и btn btn-primary соответственно
GitHub
, а вкладки меню реализованы элементами <a class="tab ...">
GitHub
. Повторяя эти шаблоны, вы обеспечите визуальную консистентность.

Select2 и выпадающие списки: Если интерфейс требует продвинутых выпадающих списков (с поиском по опциям, множественным выбором и т.п.), используйте единый подход, принятый в проекте. В настоящее время базовые выпадающие списки оформлены с помощью стилизованных элементов <select class="select ..."> (DaisyUI)
GitHub
. При необходимости добавить функциональность автодополнения или поиска, рекомендуется подключить библиотеку Select2 (или аналог) и привести её оформление в соответствие с общим стилем (насколько это возможно, через кастомную тему или CSS). Важно: избегайте разных плагинов для одного типа элементов – все выпадающие списки в проекте должны выглядеть и работать схожим образом.

Единый стиль страниц: Разрабатывая новую страницу, следуйте уже заданной структуре страниц. Используйте основной шаблон templates/base.html для консистентности шапки, подвала и подключения скриптов. Новая страница должна вписываться в текущую навигацию (добавьте пункт в меню, если необходимо, см. пример формирования меню в base.html
GitHub
). Придерживайтесь той же сетки и отступов (в base.html контент обёрнут в контейнер с классами mx-auto max-w-7xl px-6 md:px-8 py-6 и т.д.
GitHub
 – используйте похожую структуру). Следите за адаптивностью: приложение рассчитано на использование на разных размерах экрана, поэтому проверяйте, что ваши изменения корректно отображаются на мобильных устройствах.

Иконки и графика: В рамках проекта для обозначения действий используются текстовые подписи или emoji (например, значок "🔄" на кнопке обновления статуса фида
GitHub
). Старайтесь придерживаться подобных решений или, если нужны иконки, использовать уже применяемый набор (например, веб-шрифты или стандартные emoji) – это упростит поддержку и исключит разнобой стилей. Новые изображения или значки добавляйте только если без них не обойтись, и убедитесь, что они хорошо сочетаются с существующей цветовой темой.

Резюмируя, интерфейс проекта должен выглядеть цельно и профессионально. Любые дополнения – будь то новая форма ввода, таблица или диалог – должны выглядеть так, будто были частью изначального дизайна. Достичь этого поможет повторное использование существующих стилей Tailwind/DaisyUI и внимательное отношение к деталям (отступы, размеры шрифтов, состояния наведения и т.д.).

Документирование функций

Качественная документация кода – одно из требований проекта. Каждая функция или модуль, добавленные в систему (на Python или JavaScript), должны сопровождаться описанием, оформленным по стандартам проекта. Основные правила документирования такие:

Одна функция – один файл (где применимо): Логически обособленные функции и компоненты выносятся в отдельные файлы. Например, если вы реализуете новый модуль интеграции, создайте для него отдельный файл (в каталоге services/ или другом соответствующем разделе проекта). Это не строгое требование для каждого мелкого метода, но общий подход – не смешивать несвязанные функции в одном файле. Такой подход улучшает читаемость и упрощает навигацию по коду.

Документация в каталоге docs/: В репозитории есть каталог docs/ (или doc/), где хранится документация по модулям и функциям. Каждая новая функция или модуль должна быть отражена в документации. Описание можно добавлять в общий файл (например, modules_documentation.md) либо создавать отдельный .md файл, если это крупный компонент. Формат описания уже задан на примерах существующих функций:

Указывайте назначение функции – кратко, что она делает в контексте бизнеса или задачи.

Перечисляйте входные параметры (с указанием типов, если не очевидно) и что они означают.

Описывайте возвращаемое значение и тип результата.

Если функция может генерировать исключения или имеет важные побочные эффекты – отметьте это отдельно.

При наличии зависимостей или взаимодействий с другими модулями, перечислите связи с другими скриптами (например: от чего зависит, что вызывает).

Упомяните, где функция расположена в структуре проекта (путь к файлу), чтобы по документации можно было быстро её найти.

Пример оформления документации функции на Python из проекта:

#### require_login() -> Response | None  
- **Назначение**: защита маршрутов, требующих входа.  
- **Параметры**: нет.  
- **Возвращает**: редирект на страницу входа или `None`.  
- **Исключения**: нет.  
- **Локальные переменные**: `open_eps` — набор открытых эндпоинтов.


Как видно, используется четкая структура с выделением ключевых частей описания
GitHub
. Аналогичного стиля следует придерживаться и для JavaScript-функций (описание можно включать в Markdown-документацию или, при необходимости, в виде JSDoc-комментариев в коде, но предпочтительно именно в .md файле для единого подхода).

Актуальность документации: После реализации новой функции необходимо обновить документацию прежде, чем слияние изменений. Документ должен отражать конечное поведение кода. Если в ходе ревью или доработок логика функции изменилась, не забудьте скорректировать описание. Поддерживайте документацию в актуальном состоянии – это существенно поможет другим разработчикам.

Документация веб-страниц: Помимо функций, в проекте принят стандарт на описание веб-страниц приложения (пользовательского интерфейса). Существуют рекомендации по разделам документации страницы (назначение, компоненты UI, сценарии, API-взаимодействия и т.д.). Подробнее шаблон описан в файле WEB_PAGES_DOCUMENTATION_STANDARD.md. При добавлении новой страницы, помимо кода, подготовьте для неё файл документации в docs/ по этому стандарту, либо дополните существующий раздел. Хотя это выходит за рамки документирования функций, соблюдение этого правила приветствуется для целостности знаний о проекте.

Следуя данным правилам, вы облегчите сопровождение проекта: каждый кусочек логики будет задокументирован и понятен без изучения исходников. Помните, что хороший docs/ – это лицо проекта для каждого нового участника команды.

Работа с маркировкой

Одно из ключевых направлений функциональности – интеграция с национальной системой маркировки товаров "Честный Знак" и сопряженными сервисами. Здесь описаны основные процессы и рекомендации, связанные с работой КМ (кодов маркировки), а также использование криптографической подписи.

Аутентификация в системе Честный Знак (True API) и СУЗ

Для взаимодействия с True API (прямой API ГИС МТ) и СУЗ-облаком требуется проходить аутентификацию с использованием усиленной квалифицированной электронной подписи (УКЭП). Процедура следующая:

Получение токена True API: Необходимо выполнить двухшаговый вход. Сначала через GET-запрос .../auth/key получаем уникальную пару uuid и data (случайная строка)
GitHub
. Затем эту строку data подписываем УКЭП (формируется подпись в формате PKCS#7). После этого вызываем POST .../auth/simpleSignIn, передав uuid и полученную подпись, чтобы обменять их на JWT-токен аутентификации
GitHub
. Если всё прошло успешно, сервер возвращает токен (или uuidToken, в случае использования особого режима единого токена)
GitHub
. Данный токен действителен в течение ~10 часов
GitHub
. Приложение сохраняет его (например, в сессии) и подставляет в заголовок Authorization: Bearer ... для последующих вызовов True API.

Авторизация и получение clientToken для СУЗ: СУЗ (сервис заказа кодов) использует схожий механизм, но с дополнительным идентификатором соединения. Предварительно ваш аккаунт должен иметь зарегистрированное устройство (OMS) в ЛК Честного Знака. Если вы работаете через интегратора, нужно один раз зарегистрировать соединение интегратора, выполнив POST запрос на специальный URL, чтобы получить omsConnection (GUID)
GitHub
. После этого аутентификация происходит по шагам:

GET-запрос .../auth/key на адрес СУЗ (или интеграторский, если используете) – получаем данные для подписи, аналогично True API.

Подписываете data своим сертификатом УКЭП.

POST-запрос .../auth/simpleSignIn/{omsConnection} – передаете подписанные данные; в ответ получаете clientToken
GitHub
GitHub
.

Полученный clientToken является аналогом сессионного токена для запросов к СУЗ-API. Он привязан к вашему OMS_ID и действует ограниченное время. Все дальнейшие обращения к методам СУЗ должны включать заголовок clientToken: <token> и параметр omsId=<OMS_ID> в URL. В .env файле проекта предусмотрены поля для хранения этих значений (omsId, токен) на время сессии
GitHub
.

Рекомендации: процедура получения токенов должна быть реализована таким образом, чтобы не блокировать основной поток приложения. Поскольку для подписания требуется взаимодействие с плагином CryptoPro на фронтенде, серверная часть ожидает готовый подписанный блок. Убедитесь, что фронтенд-скрипты правильно вызывают эндпоинты /auth/key и затем simpleSignIn с подписью (см. раздел про CryptoPro ниже). Также, при каждой операции проверяйте валидность токена: если срок жизни истек, потребуется повторить аутентификацию.

Заказ кодов маркировки (КМ) через СУЗ

После получения clientToken и наличия действующего omsId можно заказывать коды маркировки для товаров:

Отправка заказа КМ: Запрос на заказ выполняется через POST к ресурсу .../api/v2/<товарная_группа>/orders?omsId=... (например, для молочной продукции <pg>=milk)
GitHub
. Тело запроса – JSON, содержащий необходимое количество кодов, информацию о товаре/партиии, идентификатор производственного заказа и т.д. (согласно спецификации Swagger СУЗ для соответствующей товарной группы). В заголовке должен присутствовать clientToken.

Получение кодов: Если запрос на заказ прошел успешно, система СУЗ поставит его в очередь. Проверять статус заказа можно вызовом GET /orders/<orderId> или через события. Когда заказ выполнен, коды маркировки (КМ) становятся доступны – их можно скачать (обычно как PDF/CSV или массив JSON с кодами, в зависимости от API). На этом этапе коды имеют статус ISSUED (выданы, не введены в оборот).

Отчет об использовании (ввод в оборот): После того, как вы нанесли полученные КМ на товар и подготовили продукцию к вводу в оборот, необходимо отправить уведомление об использовании кодов. В терминологии API СУЗ это перевод кодов в статус APPLIED. Делается это через вызов POST /api/v2/<pg>/reportApplied?omsId=... (либо другой соответствующий метод, в зависимости от группы товара), передавая список использованных кодов. Таким образом, вы подтверждаете, что коды нанесены на продукцию
GitHub
.

Агрегация (опционально): Если ваш бизнес-процесс подразумевает агрегирование – например, вложение промаркированных товаров в короба с собственными агрегатными кодами – то после ввода кодов в оборот можно отправить отчет об агрегировании. СУЗ-API предоставляет метод для передачи иерархической структуры "короб - вложенные коды" (отчет об агрегировании). Его вызов не обязателен, если вы не делаете агрегирование на своей стороне
GitHub
.

Отслеживание статусов кодов: После всех операций над кодами (заказ, применение, агрегация) важно убедиться, что они получили требуемые статусы в системе ЧЗ. Для этого используется True API: можно запрашивать информацию по конкретному коду маркировки (КИ) через метод /lk/products/{ki}/status или проверять статус документов (см. ниже). Обычно, после успешного отчета об использовании, статус КИ становится APPLIED, а после ввода в оборот – INTRODUCED. Если код был агрегирован, его статус может отражать это до момента ввода.

Проект автоматизирует многие из этих шагов через веб-интерфейс: есть UI для заказа кодов (формирование JSON заказа), получения результата и последующей отправки отчетов. Важно: при доработке функционала убедитесь, что все запросы соответствуют актуальной версии API. URL и форматы могут меняться, проверяйте актуальные спецификации (например, новые методы могут появляться в /api/v4/* у True API
GitHub
).

Движение товара в обороте (документы Честного Знака)

Помимо получения кодов, система должна отправлять сведения о движении маркированного товара (ввод в оборот, отгрузка, приемка, вывод из оборота и пр.) в ГИС МТ. Для этого True API предоставляет единый метод создания документов:

Создание документа движения: вызов POST /lk/documents/create?pg=<код_группы> позволяет сгенерировать документ нужного типа, например:

pg=LP_INTRODUCE_GOODS – ввод товаров в оборот (для отечественного производства),

pg=LP_SHIPMENT – отгрузка (реализация) товаров,

pg=LP_ACCEPTANCE – приемка импортированных или возвращенных товаров,

pg=LP_WITHDRAWAL – вывод из оборота (например, розничная продажа через кассу) и т.д.

Тело запроса – это JSON, содержащий заполненный документ движения, включая список кодов маркировки (поле product_document). Особенность: данный JSON-документ необходимо подписать УКЭП перед отправкой.

Подпись документов: Проект реализует открепленную подпись CAdES-BES – это значит, что сам JSON документа остаётся в теле запроса, а его подпись передается отдельно. True API ожидает, что поле product_document (содержащее данные о товаре и кодах) будет подписано электронно. В контексте API это обычно делается путём передачи специального заголовка или параметра, но в версии v3/v4 True API сделано проще: достаточно отправить документ в запросе, а сам запрос отправлять с контент-типом JSON и заголовком авторизации. Сервер на своей стороне проверит подпись. Как формируется подпись в проекте:

На фронтенде, после формирования JSON, вызывается функция подписи через CryptoPro (см. ниже). Полученная сигнатура (BASE64, формат открепленной подписи) передается на сервер.

На сервере, если требуется, может производиться склейка подписей или добавление информации. Но в нашем проекте предпочтительно подписывать сразу на клиенте, чтобы не хранить открытые ключи на сервере.

Отправка документа: После успешной подписи вызывается соответствующий метод True API. Например, для ввода в оборот готовится JSON-документ и отправляется через documents/create с параметром ?pg=.... Если ответ возвращает статус CHECKED_OK, документ принят без ошибок. В ином случае в ответе придут ошибки валидации, которые необходимо отобразить пользователю и исправить. Приложение содержит логику по отслеживанию статусов отправленных документов (например, хранит feed_id и позволяет вручную запросить обновлённый статус)
GitHub
.

Получение ответов и ошибок: True API может возвращать как JSON, так и бинарные данные (например, архив с квитанцией) в ответ на создание документов. Чтобы корректно получать ответ, приложение выставляет заголовок Accept: */* при запросах
GitHub
. Это предотвратит ошибку 406 Not Acceptable. Если документ проведён успешно, коды маркировки перейдут в новый статус (например, введены в оборот, отгружены и т.п.), что можно проверить либо через запрос статуса документа (/doc/{docId}/info), либо по каждому коду.

Интеграция CryptoPro (электронная подпись)

Для всех операций, требующих УКЭП, проект использует связку CryptoPro CSP + плагин для браузера:

На стороне клиента (в браузере) должен быть установлен плагин CryptoPro Browser Plug-in и включено соответствующее расширение (для Chromium-браузеров, таких как Chrome, Яндекс.Браузер, Edge)
GitHub
. Без установленного плагина пользователь не сможет подписывать данные – предусмотрен вывод предупреждения об отсутствии плагина (см. элемент #nkPluginMsg в шаблоне, который отображается, если плагин не найден
GitHub
).

Фронтенд-скрипты взаимодействуют с плагином через JavaScript API (в проекте есть файл static/js/cadesplugin_api.js, предоставляющий функции для работы с CryptoPro). При открытии окна подключения НК или при инициировании заказа КМ, скрипт запрашивает у плагина список доступных сертификатов, заполняет выпадающий список (элемент <select id="certSelect"> в модальном окне подключения НК
GitHub
). Пользователь выбирает свой сертификат для подписания.

Для подписи данных реализованы два подхода:

Подпись входа (auth): подписывается короткая строка data (полученная с сервера) с помощью личного сертификата. Результат – PKCS#7 подпись в Base64. Она отправляется серверу для обмена на токен (как описано выше).

Подпись документов: подписывается содержимое JSON (например, product_document для ввода в оборот) в режиме detached (открепленная подпись). Результат (CAdES-BES) также в Base64, его необходимо отправить вместе с документом.

На серверной стороне предусмотрен вспомогательный метод sign_detached(data: str) в services/true_api.py, но он в основном используется для отладки
GitHub
GitHub
. В боевом режиме подписывать должен именно клиент через плагин. Серверный метод sign_detached пытается вызвать внешнюю утилиту, указанную в переменной окружения SIGN_TOOL, и если не находит, возвращает просто base64 от данных (т.е. не настоящую подпись)
GitHub
GitHub
. Это сделано для возможности тестировать функциональность без CryptoPro (например, в разработке, чтобы не блокировать процессы отсутствием подписи). На продакшене обязательно убедитесь, что используется реальная подпись, иначе API ЧЗ не примет документы.

Рекомендации по маркировке и ЭП: Вся область маркировки строго регламентирована, поэтому:

Пользуйтесь официальными гайдами: в репозитории приведён подробный гайд по интеграции с Честным Знаком (файл AGENTSCS.md), где расписаны основные шаги и примеры запросов
GitHub
. При доработках проверяйте соответствие этим рекомендациям.

Логируйте ключевые этапы: получение токена, заказы КМ, отправку документов. Логи помогут при расследовании ошибок (например, если подпись не подошла или JSON невалидный).

Обрабатывайте ошибки API: True API и СУЗ возвращают понятные сообщения об ошибках (например, неправильная подпись, просроченный токен, превышение лимита запросов). Предусмотрите их отображение пользователю или хотя бы запись в лог.

Безопасность: УКЭП – эквивалент подписи уполномоченного лица. Никогда не передавайте секретный ключ или пароль к сертификату на сервер. Проект соблюдает это, выполняя все критичные подписи на стороне клиента.

Таким образом, модуль маркировки обеспечивает полный цикл работы с кодами: от их заказа до списания, используя API Честного Знака. Соблюдайте описанные процессы, и интеграция будет корректной и надёжной.

Структура сборочных файлов и обработка заказов

В процессе работы приложение создает и манипулирует множеством файлов и временных данных – от JSON-структур заказов до результатов обработки. Важно поддерживать организованную структуру каталогов, чтобы отслеживать прогресс обработки и разделять данные разных типов. В проекте принята следующая структура размещения файлов по папкам этапов обработки:

Каталог orders/: здесь группируются файлы, связанные с заказами на коды маркировки и сопутствующие документы. Внутри есть подразделение по направлению движения товара:

orders/supply/ – для операций, связанных с вводом товара в оборот (supply – поставка/поступление товара). Сюда относятся, например, заказы КМ для производства или импорта, акты ввода в оборот.

orders/demand/ – для операций, связанных с выводом товара из оборота (demand – спрос/реализация). Здесь могут храниться документы отгрузки, сведения о выводе по реализованному товару, возвраты и т.д.

Каждая из этих папок в свою очередь разделена по состояниям:

current/ – текущие (активные) заказы или документы. Сюда приложение помещает файлы, которые сейчас находятся в процессе обработки. Например, когда формируется JSON заказ на КМ, ему присваивается уникальное имя и сохраняется в orders/supply/current/ до получения результата. Или когда отправляется документ на ввод в оборот, его копия может сохраняться тут до подтверждения.

processed/ (или completed/) – завершенные операции. После того, как заказ выполнен (коды получены) или документ успешно принят, соответствующий файл переносится из current в папку завершенных. Название может содержать дату или идентификатор (например, orders/supply/completed/order_12345.json), чтобы можно было восстановить историю.

failed/ (опционально) – если обработка не удалась (например, ошибка в ответе API), файлы можно переместить в папку с ошибками для дальнейшего разбирательства.

Такая организаци-я обеспечивает прозрачность: вы в любой момент можете зайти в orders/supply/current и увидеть, какие заказы КМ сейчас ждут обработки, или проверить orders/demand/completed для уже отправленных актов вывода.

Каталог responses/ (пример): помимо исходящих запросов, приложение может сохранять и входящие ответы от внешних систем. Например, полученные от СУЗ файлы с кодами, квитанции о вводе в оборот, ответы НК на отправку карточек. Имеет смысл хранить их отдельно, чтобы не смешивать с исходящими запросами. По аналогии, можно завести структуру responses/supply/... и responses/demand/... или распределять их по именам файлов (например, order_12345_response.json рядом с исходным заказом).

Логи и временные файлы: все вспомогательные и временные файлы (например, CSV с кодами, если выгружается, или временные ZIP-архивы) также должны размещаться упорядоченно. Если файл относится к конкретному заказу или документу, сохраните его вместе с ним (например, order_12345.pdf в папке completed). Если же это общий временный файл – храните в отдельном каталоге (tmp/), который очищается периодически.

Отслеживание прогресса: Распределение файлов по папкам текущих/завершенных выполняет ещё одну задачу – позволяет программе и разработчикам понимать этап. Например, если файл присутствует в orders/supply/current, значит, по нему ещё не пришёл ответ или не выполнен следующий шаг. Можно реализовать фоновые задачи, которые проверяют эти папки и предпринимают действия: повторные попытки, уведомления или перемещение при таймауте.

При разработке нового функционала соблюдайте существующую структуру. Добавляйте новые папки, только если появляется новый тип данных, который не вписывается в текущие (например, если появится учет возвратов, можно добавить orders/returns/). Не складывайте разнородные файлы в одну директорию. И обязательно документируйте новые каталоги и их назначение в данном разделе документации.

Технологический стек и стиль кода

Проект ms_products-main построен с использованием современных технологий веб-разработки, сочетающих надежность Python на сервере и гибкость JavaScript на клиенте. Ниже перечислены основные компоненты и даны рекомендации по их использованию:

Backend: фреймворк Flask (Python) – легковесный веб-фреймворк, организующий маршруты, логику API и рендеринг страниц. Flask выбран за его простоту и расширяемость. Приложение запускается стандартным образом (см. app.py) и использует сессии для хранения токенов и временных данных. Рекомендуемый стиль кода – придерживаться PEP8, имена переменных и функций выбирать говорящие. Логика интеграции разнесена по модулям (например, nk_api.py для работы с Национальным каталогом, services/true_api.py для запросов ЧЗ и т.д.). Совет: при добавлении нового модуля интеграции или фонового процесса, регистрируйте его либо через Blueprint Flask (если это набор новых маршрутов), либо как отдельный сервис, вызываемый из существующих маршрутов.

Database: Явной базы данных в проекте нет – данные хранятся в системах МойСклад и Честного Знака, а приложение их лишь читает и передает. Однако, если потребуется временное хранение (кэш, очереди), можно использовать встроенные возможности Flask (сессии, серверные файлы) либо подключить легковесную БД (SQLite) или k-v хранилище (Redis) при соблюдении требований. На данный момент подобного нет, и добавляя его, необходимо не нарушить существующий поток (например, не блокировать получение данных напрямую из МойСклад API).

Frontend: интерфейс построен на HTML5 + Tailwind CSS + JavaScript. Используется утилитарный CSS-фреймворк Tailwind для оформления и DaisyUI как надстройка для готовых компонентов (кнопки, формы, темы)
GitHub
GitHub
. Сборка CSS и поддержка модульности организована через Vite (см. vite.config.mjs), что позволяет использовать современные возможности фронтенда. В проекте не используется крупный фреймворк вроде React/Vue – весь JS написан нативно или с небольшой помощью утилитных библиотек. Некоторые страницы могут подключать сторонние скрипты:

Select2: (планируется/возможно) для улучшения выпадающих списков.

CryptoPro plugin API: скрипт cadesplugin_api.js для работы с криптографическим плагином.

Организация файлов фронтенда такова: исходные стили в src/styles.css с директивами Tailwind, итоговый скомпилированный CSS – в static/dist/tailwind.css. JS-файлы разложены по функциональности в static/js/ (напр. nk_auth.js для авторизации в НК, table.js для логики таблицы товаров и работы с UI). При добавлении нового JS-модуля разместите его в static/js/ и подключите в шаблоне при необходимости. Следите за именованием (например, логично группировать функциональность по страницам или по типу интеграции). Минимизируйте использование глобальных переменных; при необходимости, используйте пространства имен (например, window.MyModule = {...}) или IIFE.

Coding style и форматирование:

Для Python-кода придерживайтесь стандартов PEP8: 4 пробела отступ, разумная длина строк (~120 символов), именование в snake_case для функций/переменных и CamelCase для классов. В репозитории может быть настроен линтер/форматтер – при наличии, запускайте его перед коммитом.

Для JavaScript придерживайтесь схожих правил: используйте понятные имена, соблюдайте единый стиль кавычек, точек с запятой и пр. (например, во всем коде проекта используется точка с запятой опционально, а строки обрамляются кавычками " – следуйте той же конвенции). Можно воспользоваться утилитами форматирования (Prettier, ESLint) с настройками, совпадающими с существующим кодом, если они подключены.

Комментарии приветствуются для сложной логики, но избегайте избыточных. Большую часть объяснений выносите в документацию (docs/), а в коде оставляйте комментарии TODO или пояснения неочевидных мест.

Структура файлов: Проект уже разбит на смысловые части. Не размещайте новые классы или функции в случайных файлах. Например, если появляется интеграция с новой системой, создайте новый модуль в services/ или в корне, по аналогии с nk_api.py и true_api.py. Шаблоны (HTML) для новых страниц кладите в templates/ (создавая поддиректорию, если страницы относятся к отдельному блоку функциональности, либо прямо в корень templates для одиночных страниц). Статические файлы – в static/ с дальнейшим делением по типу (CSS, JS, media).

Зависимости: При добавлении новых Python-зависимостей – не забудьте обновить requirements.txt. Для JS-пакетов – package.json. Проверяйте, что новые зависимости не дублируют функциональность существующих библиотек.

Тестирование: Хотя в bullet-пунктах не упоминалось явно, но технология разработки подразумевает тестирование. В проекте присутствуют тестовые скрипты, но отсутствует явный тестовый фреймворк. Если добавляете новую критичную функцию, постарайтесь написать для неё простой self-test (например, в docstring или отдельном файле в test/), чтобы можно было проверить работоспособность. В будущем планируется подключение полноценного тестирования, поэтому код лучше сразу писать с учетом возможной автоматической проверки (чистые функции без глобального состояния, разделение побочных эффектов и логики и т.д.).

Итого по стеку: Flask обеспечивает серверную часть, Tailwind (с Vite) – удобство и скорость вёрстки, JavaScript – интерактивность на клиенте, а CryptoPro – безопасность через ЭП. Комбинация этих технологий должна быть использована максимально эффективно и согласованно. Соблюдайте стиль и структуру кода, принятые в проекте, и это сделает развитие системы более предсказуемым и управляемым.
